%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LATEX-TEMPLATE TECHNISCH RAPPORT
%-------------------------------------------------------------------------------
% This template is derived from the AVI PT report template.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-------------------------------------------------------------------------------
%	PACKAGES EN DOCUMENT CONFIGURATIE
%-------------------------------------------------------------------------------

\documentclass{uva-inf-article}
\usepackage[style=apa]{biblatex}
\addbibresource{PT-essay.bib}

\usepackage{listings}

%-------------------------------------------------------------------------------
%	GEGEVENS VOOR IN DE TITEL
%-------------------------------------------------------------------------------

% Vul de naam van de opdracht in.
\assignment{Individual Written Assessment}
% Vul het soort opdracht in.
\assignmenttype{Essay}
% Vul de titel van de eindopdracht in.
\title{Designing \texttt{legalease}, a Smart Contracts programming language}

% Vul de volledige namen van alle auteurs in.
\author{René Kok}
% Vul de corresponderende UvAnetID's in.
\uvanetid{13671146}

% Vul eventueel ook de naam van de docent of vakcoordinator toe.
\docent{dr. Ana Oprescu}
\course{Programmeertalen}
% Te vinden op onder andere Datanose.
\courseid{5062PROG6Y}

% Dit is de datum die op het document komt te staan. Standaard is dat vandaag.
\date{\today}

%-------------------------------------------------------------------------------
%	VOORPAGINA
%-------------------------------------------------------------------------------

\begin{document}
\maketitle

%-------------------------------------------------------------------------------
%	INHOUDSOPGAVE EN ABSTRACT
%-------------------------------------------------------------------------------

% Niet doen bij korte verslagen en rapporten
%\tableofcontents
%\begin{abstract}
%\lipsum[13]
%\end{abstract}

%-------------------------------------------------------------------------------
%	INTRODUCTIE
%-------------------------------------------------------------------------------

\section{Introduction}
Smart Contracts (\cite{what-are-smart-contracts}) are key to simplify complex blockchain transactions.
Smart contracts can streamline this complex process that involves several intermediaries because of a 
lack of trust among participants in the transaction.

The ultimate goal of this essay is to design a programming language that best fits the use cases of smart contracts.
The language is designed on the basis of the following characteristics: 
the type system,
state management,
compilation/interpretation strategy,
evaluation strategy (lazy/eager),
parameter evaluation strategy (call by value/reference),
communication semantics (synchronous/asynchronous),
higher-order functions and anonymous functions.

\subsection{Relevant characteristics of application domain}
Smart contracts are automated contracts or workflow with specific instructions programmed.
They help people exchange anything of value in a transparent way while avoiding intermediaries.
Smart contracts can be applied in any industry where transactions take place.
\vspace{5mm}

IBM says the following about smart contracts:\\
\textit{"Smart contracts work by following simple “if/when…then…” statements that are written 
into code on a blockchain. A network of computers executes the actions  when predetermined conditions have been 
met and verified. These actions could include releasing funds to the appropriate parties, registering a vehicle, 
sending notifications, or issuing a ticket. The blockchain is then updated when the transaction is completed. 
That means the transaction cannot be changed, and only parties who have been granted permission can see the results"}
(\cite{ibm-smart-contracts}).
\vspace{5mm}

legalease is written for ethereum and the smart contracts are run in a virtual machine because 
it needs to be deterministic, terminable and isolated.
A program can yield different outputs on different types of machines.
For a smart contract you want the output to always yield the same results.

\subsection{Use case description}
% TODO
\newpage

%-------------------------------------------------------------------------------
%	METHODE
%-------------------------------------------------------------------------------
\section{Analysis}
\subsection{The type system}
\par A type system defines how a programming language groups data into different data types.
The major categories of the type system are: static or dynamically typed, manifest or inferred 
type inference and nominal or structural type system.
\vspace{5mm}

\par The purpose of a type checker is to prevent an incorrect operation from being executed.
A static type checker does this by stopping the compiler from generating a program with type errors, 
a dynamic type checker halts the program as it is about to make a type error (\cite{matthews1987static}).
Because smart contracts are designed for transactions, a smart contract needs to be accurate and secure. 
No hidden surprises at runtime.
That is why I chose to have the language static typed.
Static type checking has the advantages that the smart contract is guaranteed to meet a number of type safety features for all possible inputs.
In addition, a static typing language is better optimized as opposed to dynamically typed language, because the compiler knows if a program is correctly typed.
This results in a smaller and faster binary because no dynamic safety checks need to be performed.
\vspace{5mm}

\par The purpose of type inference is to retrieve the type of an declared variable.
Manifest typing is an explicit identification and requires that the the type of each variable is declared.
Inferred typing determines the type of an variable by the type of the assigned initialization expression.
While type inference does not affect runtime of a program, because types are inference occurs at compile-time,
an explicit type inference seems to be the best choice for smart contracts because  
explicit type annotations serve as documentation for the code.
\vspace{5mm}

\par I also made the choice for nominative typing. 
While structural typing is more flexible, nominative typing is less prone to errors.
It's common for objects to be structural equivalent, but semantically different.
polymorphism can be implemented through a shared interface such as in the Java programming language.

\subsection{State management}
\par A program can be stateful or stateless. A stateful program stores it's state in variables.
These variables can be read or mutated during execution of the program.
A stateless program does not store it's state in variables. 
The program's data is passed through chained functions.\vspace{5mm}

\par A stateless program is according to research more reliable (\cite{Merelo2018}) because it is not depending on it's state.
Because it doesn't rely on it's state, multithreading is easier to program then a stateful program. 
Because the synchronization of the states no longer has to be taken into account (\cite{Merelo2018}).
Because of these reasons my language will be stateless.

\newpage
\subsection{Compilation/interpretation strategy}
\par Just-in-time (JIT) compilation during program execution and ahead-of-time (AOT) compilation during 
software installation are alternate techniques used by managed language virtual machines (VM) to 
generate optimized native code while simultaneously achieving binary code portability and 
high execution performance (\cite{wade2017aot}).
\vspace{5mm}

\par I've chosen for an ahead-of-time compilation. In contrast to the JIT compiler, 
the original source code does not have to be supplied, but a compiled smart contract is uploaded.
Normally, a compiled version must be written for each type of system. 
This is not the case for our smart contracts, as the code only runs on a specialized virtual machine 
designed for our blockchain. AOT compilers can also perform more complex and advanced code optimizations,
which in most cases of JIT compiling is considered to be too costly.
With AOT compilation, the programs runs faster because the program is already compiled before running.

\subsection{Evaluation strategy}
\par In a function call, arguments expressions may be evaluated eagerly 
to obtain the arguments value before evaluating the function body.
Alternatively, one might evaluate arguments lazily, that is, postpone evaluation 
of the arguments until we have seen that the value of the argument is really needed.
If the argument is not needed, the argument is never evaluated. If it is, 
then the argument is evaluated and cached in case it will be needed again
(\cite{Sestoft2012-2}).
\vspace{5mm}

\par I made the choice for an eager evaluation strategy to avoid unexpected behavior.
In addition, lazy evaluation is difficult to combine with imperative functions such as 
input/output, because the order of operations becomes indeterminate.

\subsection{Parameter evaluation strategy}
\par The most common way of parameter evaluation strategy are call by value and call by reference. 
With call by value, a copy is made of the data structure. When the copy is adjusted within the function, 
the original remains the same. With call by reference, the original value is adjusted.
\vspace{5mm}

\par Since legalease's state management is stateless, it is not possible to provide a value 
per reference, as it does not have a state to reference.

\subsection{Communication semantics (synchronous/asynchronous)}
\par Asynchronous communication means that the program executes an action and then does not wait for the result while it continues. 
In synchronous communication, the program waits for the result of the action before continuing.
\vspace{5mm}

As far as I know, there is no language that is completely asynchronous. 
I want my programming language to be synchronous, but it needs to support asynchronous communication semantics.
For example, information can be retrieved from multiple sources at the same time by means of asynchronous requests, 
which means that the processing time of a smart contract is shorter than when this information is retrieved synchronously.

\newpage
\subsection{Higher-order functions}
\par A higher-order functional language is one in which a function may be used as a value, 
just like an integer or a boolean. That is, the value of a variable may be a function, 
and a function may take a function as argument and may return a function as a result
(\cite{Sestoft2012}).
\vspace{5mm}

\par I want my programming language to support higher-order functions.
A good use-case for higher-order functions is validating an object.
The basic idea is a function that takes an object as an argument and then any number of 
functions that must evaluate to true for the object to be considered valid.
See "Appendix A: Higher-order functions example" For a short example of applying 
Higher order functions to validate an object.

\subsection{Anonymous functions}
\par Anonymous functions, also called lambda expressions or lambdas, are functions that are not tied to an identifier.
Anonymous functions are often used in combination with higher-order functions (\cite{HigherOrder}).
\vspace{5mm}

\par A few minor disadvantages have emerged during my research into anonymous functions. 
These points are:
Anonymous functions are harder to debug and anonymous functions are not reusable. 
Because anonymous functions are an addition to the language and not a trade-off, 
I have made the choice to offer support for anonymous functions. 
So programmers are free to make use of anonymous functions.

\section{Discussion}
In deze essay wordt er op een zeer abstract niveau gekeken naar de mogelijk karakteristieke 
voor de taal legalease. 

\section{Conclusions}
% TODO

%-------------------------------------------------------------------------------
%	REFERENTIES
%-------------------------------------------------------------------------------

\printbibliography

%-------------------------------------------------------------------------------
%	BIJLAGEN EN EINDE
%-------------------------------------------------------------------------------
\newpage
\section{Appendix A: Higher-order functions example}
\lstinputlisting[basicstyle=\small, language=C]{resources/higher_order_example.c}
\end{document}
